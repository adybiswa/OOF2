# -*- python -*-

# This software was produced by NIST, an agency of the U.S. government,
# and by statute is not subject to copyright in the United States.
# Recipients of this software assume all responsibilities associated
# with its operation, modification and maintenance. However, to
# facilitate maintenance we ask that before distributing modified
# versions of this software, you first contact the authors at
# oof_manager@nist.gov.

# The PropertyOutputRegistration subclasses create an Output object
# for each registered PropertyOutput.  This bridges the gap between
# the C++ PropertyOutputs and the more general Python Outputs.

from ooflib.common import debug
from ooflib.common import utils

class _PORegBase(PropertyOutputRegistration):

    # initializer is either a PropertyOutputValInit object, or None.
    # If it's None, a default initializer will be used, which
    # initializes the OutputVal to zero (or the equivalent).  Most of
    # the time, the default should be sufficient.
    # Subclasses' constructors must create an actual Output object and
    # pass it in here as the 'output' argument.
    def __init__(self, name, output, initializer=None):
        self.initializer = initializer
        self.output = output
        PropertyOutputRegistration.__init__(self, name)
        
    ## Callback for all PropertyOutputs.  Outputs that need to return
    ## something other than a list of OutputVal instances should
    ## override the convert method.
    def opfunc(self, mesh, elements, coords, **params):

        # instantiate is PropertyOutputRegistration.instantiate,
        # defined in propertyoutput.h.  It calls
        # PropertyOutputInit::instantiate and creates an instance of a
        # PropertyOutput subclass.
        po = self._instantiate(self.name(), params)

        # Store the currently active PropertyOutput in self, so that
        # it can be used if instancefn or zeroVal need to examine any
        # parameters.  This is thread safe because self.output is
        # cloned before this point.
        self.output._propertyOutput = po

        # initializer initializes the OutputVal at each evaluation
        # point. If an initializer wasn't provided, the default
        # initializer just clones a zero-valued OutputVal.  The
        # initializer can't be set in _instantiate because its
        # constructor might need to retrieve parameters from the
        # Output.
        # Keep a reference to the initializer so that it persists
        # until the opfunc finishes.
        self.zeroObj = None
        if self.initializer is not None:
            self.initObj = self.initializer
        else:
            self.zeroObj = self.zeroVal(po)
            self.initObj = DefaultPropertyOutputValInit(self.zeroObj)
                        
        po.setInitializer(self.initObj)

        mesh.precompute_all_subproblems()
        results = []
        for element, ecoords, in zip(elements, coords):
            mesh.begin_all_subproblems(element)
            results.extend(po.evaluate(mesh, element, ecoords))
            mesh.end_all_subproblems(element)
        return self.convert(results)
    def convert(self, results):
        return results

    def zeroVal(self, propout):
        # Subclasses must define this method, which returns "zero" in
        # the format desired for the output.  The argument is the
        # Output object.
        raise ErrPyProgrammingError("%s.zeroVal is not defined!"
                                    % self.__class__.__name__)

    # instancefn returns an instance of the type of OutputVal that the
    # Output will produce. It's used to get attributes of the
    # OutputVal before evaluating the Output.
    # See comments in Output.outputInstance() in output.py before
    # changing this function.
    def instancefn(self, obj):
        # obj is an Output, created in the __init__ of a
        # PropertyOutputRegistration subclass.
        return self.zeroVal(obj._propertyOutput)
    

class ArithmeticPropertyOutputRegistration(_PORegBase):
    def __init__(self, name, output, initializer=None):
        _PORegBase.__init__(self, name, output, initializer)
    def _instantiate(self, name, params):
        return self.instantiateArithmetic(name, params)

class NonArithmeticPropertyOutputRegistration(_PORegBase):
    def __init__(self, name, output, initializer=None):
        _PORegBase.__init__(self, name, output, initializer)
    def _instantiate(self, name, params):
        return self.instantiateNonArithmetic(name, params)
        
