# -*- markdown -*-

# This software was produced by NIST, an agency of the U.S. government,
# and by statute is not subject to copyright in the United States.
# Recipients of this software assume all responsibilities associated
# with its operation, modification and maintenance. However, to
# facilitate maintenance we ask that before distributing modified
# versions of this software, you first contact the authors at
# oof_manager@nist.gov.

---

# OOFCanvas summary #

OOFCanvas is a replacement for libgnomecanvas, designed for use in
OOF2, but hopefully useful elsewhere. OOFCanvas is based on
[Cairo](https://www.cairographics.org/) and is compatible with gtk3.
It might eventually also be compatible with gtk+2.

OOF2 uses [libgnomecanvas](https://developer.gnome.org/libgnomecanvas/)
to display and interact with images and meshes.  But libgnomecanvas
requires gtk+2, and gtk+2 works only with python3, not python2, and
python2 is being phased out.  In order to upgrade OOF2 to python3, we
need to first upgrade it from gtk+2 to gtk+3, and to do that we need
to first replace libgnomecanvas.

The canvas is a drawing area that can display a variety of shapes,
including text. It can be scrolled, zoomed, and printed.  Items drawn
on the canvas can be selected with the mouse.

All of the code is in C++.  Wrappers for Python 2.7 have been
generated by an old version of SWIG.  Hopefully we've remembered to
distribute the SWIG output so that users don't need to run SWIG
themselves.  All the objects described here are defined in the C++
OOFCanvas namespace.

OOFCanvas is *not* a drop-in replacement for libgnomecanvas.  It's
also not a full-fledged gtk widget.  It's a set of classes that does
some of what libgnomecanvas did and uses gtk.

## Coordinate Systems ##

Objects drawn on the canvas are specified in physical units, which may
be anything convenient to the user.  The coordinate system is (x,y)
where x goes from left to right on the screen, and **y goes from
bottom to top**.   This is not the convention in many graphics
libraries, but is standard for physics.

The conversion from physical to pixel coordinates depends on the size
of the canvas and the current zoom factor, and determines the ppu
(pixels per unit).  The user should be able to use physical units and
not worry about ppu at all.

Some types of canvas items are naturally defined in terms of pixels,
however. OOFCanvas handles the scaling for these too.


## The Canvas Classes ##

Three kinds of Canvas objects are defined.

* `OffScreenCanvas is` the base class.  It can be used to make drawings
that will be printed or saved to a file, but not displayed.

* `Canvas `is derived from `OOFScreenCanvas` (via an intermediate abstract
`GUICanvasBase` class).  It creates a `Gtk.Layout` which can be used in
Gtk3 to put the `Canvas` in a GUI.  It calls user-provided callback
functions in response to mouse events.

* A slightly different Canvas class is available in Python.  It's
actually a C++ class called `PythonCanvas`, which is derived from
`GUICanvasBase` and renamed to `Canvas` when exported to Python.  The main
difference between the C++ and Python `Canvas` classes is that the
Python class expects callback functions to be Python methods, and the
`GtkLayout` is created in Python.

The pixel size of a `Canvas` or `PythonCanvas` is determined by the Gtk
window that it's part of.  The pixel size of an `OffScreenCanvas` is
only computed when it's saved as an image and the size of the image is
given.

## The CanvasLayer Class

Drawing is done by creating one or more `CanvasLayer`s and adding
`CanvasItem`s to them.  `CanvasLayer`s can be shown, hidden, and
reordered, making it easy to change what's visible on the canvas.
Opaque items in higher layers obscure the items in lower layers.

`CanvasLayer`s are created by calling `OffScreenCanvas::newLayer()` and
destroyed by calling either `CanvasLayer::destroy()` or
`OffScreenCanvas::deleteLayer()`.

The size of a layer in pixels is determined by the physical sizes of
the items being displayed, and the current `ppu`.

## The CanvasItem Classes

Everything drawn on a `Canvas` is an instance of a `CanvasItem` subclass.
Pointers to `CanvasItem`s are passed to `CanvasLayer::addItem`.  The
`CanvasLayer` will destroy its `CanvasItem`s when appropriate -- the user
should never destroy them explicitly. 

Each `CanvasItem` has a bunch of parameters that determine its position,
shape, color, and transparency.  Position parameters are always given
in physical units.  Some parameters, such as line widths, can be
interpreted in either physical or pixel units.  If the `CanvasItem` has
such a parameter, it will have a `setLineWidthInPixels` method (or the
equivalent).

Details of each `CanvasItem` subclass are given [somewhere
below](#canvasitems).

## Basic Usage

In C++

	double ppu; // pixels per unit
	Canvas canvas(ppu);
	GtkWidget *widget = canvas.gtk(); // widget is a GtkLayout.
	// [Install widget in gui]
	
	// Create a canvas layer
	CanvasLayer *layer = canvas.newLayer("layername");
	
	// Add items to the layer
	double x, y, radius;            // In physical units.
	CanvasCircle *circle = new CanvasCircle(x, y, radius);
	double w;                       // In physical units, unless ...
	circle->setLineWidthInPixels(); // .. setLineWidthInPixels is called.
	circle->setLineWidth(w);
	Color red(1., 0., 0., 0.5); // r, g, b, a, all in [0.0, 1.0]
	circle.setFillColor(red);
	layer->addItem(circle);
	
	// Draw the items to the canvas
	canvas.draw();

Calling `Canvas::draw` doesn't actually draw anything.  Instead, it
generates a Gtk event that causes `GUICanvasBase::drawHandler` to be
called from the Gtk main loop.

## Mouse 

## Scrolling

## Canvas Item Subclasses {#canvasitems}

## Other Canvas Methods

## Appendix: Internal Order of Operations

It shouldn't be necessary to understand this section in order to use
OOFCanvas.  It's here to help development.

Each `CanvasLayer` contains a `Cairo::ImageSurface` which contains a
bitmap of what's been drawn in the layer, a `Cairo::Context` which
controls drawing to surface, and a `Rectangle` which is the bounding box
(in physical coordinates) of all of the layer's `CanvasItems`. 

When a `CanvasItem` is added to a `CanvasLayer`, the layer is marked
"dirty" and the item is stored in the layer.  No drawing is done at
this point.

When all items have been added to the layers, calling
`GUICanvasBase::draw()` generates a draw event on the `GtkLayout`.  This
causes `GUICanvasBase::drawHandler()` to be called.  The argument to
drawHandler is the `Cairo::Context` for drawing to the `GtkLayout`'s
`Cairo::Surface`. 

`GUICanvasBase::drawHandler()` begins by computing the horizontal and
vertical offsets that will be used to keep the image centered in
the gtk window (if the image is smaller than the window) or at the
position determined by the scroll bars (if the image is larger than
the window).

Next, drawHandler calls `Canvas::setTransform()`, which computes the
matrix that converts from physical coordinates to bitmap coordinates
within the layer, given the ppu.  The `GtkLayout` is resized if
necessary so that it is large enough to accomodate the bounding boxes
of all of the layers, plus an optional margin (set by
`OffScreenCanvas::setMargin()`).  Note that a layer's bounding box, in
physical units, can depend on the ppu if the layer contains items with
sizes given in pixels.

Next, in the simplest case, `GUICanvasBase::drawHandler` draws the
background color and then, for each layer from bottom to top, tells
the layer to draw all of its `CanvasItems`s to its `Cairo::ImageSurface`
(`CanvasLayer::render()`), and copies the layer's surface to the
`GtkLayout`'s surface (`CanvasLayer::copyToCanvas()`) at the position
given by the scroll bars.

					 





