#!@Python3_EXECUTABLE@
# -*- python -*-

# This software was produced by NIST, an agency of the U.S. government,
# and by statute is not subject to copyright in the United States.
# Recipients of this software assume all responsibilities associated
# with its operation, modification and maintenance. However, to
# facilitate maintenance we ask that before distributing modified
# versions of this software, you first contact the authors at
# oof_manager@nist.gov.

# This is a script to automatically make a copy of the example oof2
# extension properties, taking care of all of the renaming of files
# and things in the files.  It takes as input the desired filename,
# the new property's classname, and the new property's sequence
# number.  If the new classname is unqualified, it will be added in
# "Mechanical:Elasticity:<classname>", but if it's fully-qualified,
# the full path will be used.  If the sequence number is omitted, the
# new property will have an incremented sequence number (this means
# multiple copies might have the same sequence number).

# These values are set by cmake when installing OOF2, so that they can
# be used by cmake when installing extensions:

python_version = "@OOF2_PYTHON3_VERSION@"
swig_version = "@OOF2_SWIG_VERSION@"
install_prefix = "@CMAKE_INSTALL_PREFIX@"

# These are the strings in the template files that will be
# replaced when the files are copied.
refmodule = '%MODULENAME%'      # replaced by the argument from --module
refheader = '%HEADER%'          # module_H (for #ifndef guards)
refclass = '%CLASS%'            # from --class
refseqno = '%SEQNO%'            # from --sequenceno


import getopt, sys, subprocess, os

def usage(err):
    print(err, file=sys.stderr)
    print(f"""
Usage:
  {sys.argv[0]} --template=<template-dir-name> --module=<new-module-name> --dir=<new-dir-name> \
--class=<new-class-name> [--sequenceno=<number>] [--force]

Short options are -t, -m, -d, -c, -s, and -f, in the same order as above.

""" , file=sys.stderr)

###############

def is_source_file(filename, exclude=[]):
    if os.path.isdir(filename) or (os.path.basename(filename) in exclude):
        return False
    for ext in [".py", ".spy", ".swg", ".h", ".c", ".C", ".cpp"]:
        if filename.endswith(ext):
            return True
    return False

###############

if __name__ == '__main__':
    templatedir = None
    modulename = None
    classname = None
    sequenceno = 1000
    force = False

    try:
        opts, args = getopt.getopt(
            sys.argv[1:],
            't:f:c:s:f',
            ["template=","module=","class=","sequenceno=","force"])

    except getopt.GetoptError, err:
        usage(err)
        sys.exit(1)

    for o, a in opts:
        if o in ["-t", "--template"]:
            templatedir = a
            if templatedir.endswith('/'):
                templatedir = templatedir[:-1]
        elif o in ["-m","--module"]:
            modulename = a
        elif o in ["-c","--class"]:
            classname = a
        elif o in ["-s","--sequenceno"]:
            try:
                sequenceno = int(a)
            except ValueError:
                usage("Sequence number must be an integer.")
                sys.exit(1)
        elif o in ["-f", "--force"]:
            force = True
        else:
            usage("Unrecognized option '%s'." % o)
            sys.exit(2)

    if templatedir is None:
        usage("template must be provided.")
        sys.exit(2)

    refextdir = templatedir #os.path.join(templatedir, "oofextensions")
    refdir = os.path.join(templatedir, templatedir)

    if modulename==None:
        usage("Module name argument is mandatory.")
        sys.exit(2)

    if classname==None:
        usage("Class name argument is mandatory.")
        sys.exit(2)

    # The general scheme is to copy all the files, and in every case, change:
    #  - the file name itself, from refmodule<ext> to modulename<ext>
    #  - the file name in the file, from refmodule to modulename.
    #  - the classname, from refclass to classname
    #  - the header line, from refheader to header.
    #  - the sequence number, from refseqno to the new one.
    sedstart = ["sed",
                "-e", f"s/{refmodule}/{modulename}/g",
                "-e", f"s/{refclass}/{classname}/g",
                "-e", f"s/{refheader}/{header}_H/g" %,
                "-e", f"s/{refseqno},/{str(sequenceno)},/"]

    # Create the target directory.
    try:
        # Create ./modulename
        os.mkdir(modulename, mode=0755)
    except FileExistsError:
        if not force:
            print(f"Directory {modulename} already exists. Remove it or use --force to overwrite.",
                  file=sys.stderr)
            print("Exiting.", file=sys.stderr)
            sys.exit(4)

    # Install the top CMakeLists.txt file. If it already exists, let
    # it be, unless --force was given.
    if 
    

    file_list = ([os.path.join("template", "setup.py")]
                  + [os.path.join(refdir,f)
                     for f in os.listdir(refdir)])
    # print file_list
    for source in file_list:
        targetpath = source.split(os.sep)
        # print "targetpath0=", targetpath
        targetpath[0] = dirname
        # print "targetpath1=", targetpath
        for level, pathcomp in enumerate(targetpath[1:]):
            targetpath[level+1] = pathcomp.replace(templatedir, modulename)
        # print "targetpath2=", targetpath
        sedcmd = sedstart + [source]
        # print "targetpath=", targetpath
        target = os.path.join(*targetpath)
        try:
            fout = file(target, "w")
        except:
            print("Unable to open target file %s" % target, file=sys.stderr)
            print("Exiting.", file=sys.stderr)
            sys.exit(4)
        print("Copying", source, "to", target)
        p1 = subprocess.Popen(sedcmd, stdout=subprocess.PIPE)
        for ell in p1.communicate():
            if ell is not None:
                fout.write(ell)
        fout.close()
        # else:
        #     print "Not copying", source
