#!@Python3_EXECUTABLE@
# -*- python -*-

# This software was produced by NIST, an agency of the U.S. government,
# and by statute is not subject to copyright in the United States.
# Recipients of this software assume all responsibilities associated
# with its operation, modification and maintenance. However, to
# facilitate maintenance we ask that before distributing modified
# versions of this software, you first contact the authors at
# oof_manager@nist.gov.

# This is a script to automatically make a copy of the example oof2
# extension properties, taking care of all of the renaming of files
# and things in the files.  It takes as input the desired filename,
# the new property's classname, and the new property's sequence
# number.  If the new classname is unqualified, it will be added in
# "Mechanical:Elasticity:<classname>", but if it's fully-qualified,
# the full path will be used.  If the sequence number is omitted, the
# new property will have an incremented sequence number (this means
# multiple copies might have the same sequence number).

# These values are set by cmake when installing OOF2, so that they can
# be used by cmake when installing extensions:
python_version = "@OOF2_PYTHON3_VERSION@"
swig_version = "@OOF2_SWIG_VERSION@"
oof_install_prefix = "@CMAKE_INSTALL_PREFIX@"

# These are the strings in the template files that will be
# replaced when the files are copied.
refmodule = '%MODULENAME%'      # replaced by the argument from --module
refheader = '%HEADER%'          # module_H (for #ifndef guards)
refclass = '%CLASS%'            # from --class
refseqno = '%SEQNO%'            # from --sequenceno
refpython = '%PYTHON%'
refswig = '%SWIG%'
refoof2prefix = '%OOF2PREFIX%'


import getopt, sys, subprocess, os

def usage(err):
    print(err, file=sys.stderr)
    print(f"""
Usage:
  {sys.argv[0]} --template=<template-dir-name> --module=<new-module-name> --dir=<new-dir-name> \
--class=<new-class-name> [--sequenceno=<number>] [--force]

Short options are -t, -m, -d, -c, -s, and -f, in the same order as above.

""" , file=sys.stderr)

###############

# def is_source_file(filename, exclude=[]):
#     if os.path.isdir(filename) or (os.path.basename(filename) in exclude):
#         return False
#     for ext in [".py", ".spy", ".swg", ".h", ".c", ".C", ".cpp"]:
#         if filename.endswith(ext):
#             return True
#     return False

def install_file(src, dest, sedcmd, force=False):
    # sedcmd is a list of strings, including "sed" and all its
    # arguments *except* the source file name.
    if os.path.exists(dest) and not force:
        print(f"File {dest} exists. Remove it or use --force to overwrite.",
              file=sys.stderr)
        sys.exit(1)
    try:
        fout = file(dest, "w")
    except:
        print(f"Unable to open target file {dest}!", file=sys.stderr)
        print("Exiting.")
        sys.exit(1)
    print(f"Copying {src} to {dest}.")
    p1 = subprocess.Popen(sedcmd + [src], stdout=subprocess.PIPE)
    for ell in p1.communicate():
        if ell is not None:
            fout.write(ell)
    fout.close()

###############

if __name__ == '__main__':
    templatedir = None
    modulename = None
    classname = None
    sequenceno = 1000
    force = False

    try:
        opts, args = getopt.getopt(
            sys.argv[1:],
            't:f:c:s:f',
            ["template=","module=","class=","sequenceno=","force"])

    except getopt.GetoptError, err:
        usage(err)
        sys.exit(1)

    for o, a in opts:
        if o in ["-t", "--template"]:
            templatedir = a
            if templatedir.endswith('/'):
                templatedir = templatedir[:-1]
        elif o in ["-m","--module"]:
            modulename = a
        elif o in ["-c","--class"]:
            classname = a
        elif o in ["-s","--sequenceno"]:
            try:
                sequenceno = int(a)
            except ValueError:
                usage("Sequence number must be an integer.")
                sys.exit(1)
        elif o in ["-f", "--force"]:
            force = True
        else:
            usage("Unrecognized option '%s'." % o)
            sys.exit(2)

    if templatedir is None:
        usage("template must be provided.")
        sys.exit(2)

    # templatedir is the name of a directory that was installed (by
    # OOF2/CMakeLists.txt) in <prefix>/share/oof2/templates.  refdir
    # is the full path to it.
    refbase = os.path.join(oof2_install_prefix, "share", "oof2", "templates")
    refdir = os.path.join(refbase, templatedir)

    if modulename==None:
        usage("Module name argument is mandatory.")
        sys.exit(2)

    if classname==None:
        usage("Class name argument is mandatory.")
        sys.exit(2)

    # The general scheme is to copy all the files, and in every case, change:
    #  - the file name itself, from refmodule<ext> to modulename<ext>
    #  - the file name in the file, from refmodule to modulename.
    #  - the classname, from refclass to classname
    #  - the header line, from refheader to header.
    #  - the sequence number, from refseqno to the new one.
    sedcmd = ["sed",
              "-e", f"s/{refmodule}/{modulename}/g",
              "-e", f"s/{refclass}/{classname}/g",
              "-e", f"s/{refheader}/{header}_H/g",
              "-e", f"s/{refseqno}/{str(sequenceno)}/",
              "-e", f"s/{refpython}/{python_version}/g",
              "-e", f"s/{refswig}/{swig_version}/g",
              "-e", f"s/{refoof2prefix}/{oof_install_prefix}/g"
              ]

    # Create the target directory.
    try:
        # Create ./modulename
        os.mkdir(modulename, mode=0755)
    except FileExistsError:
        if not force:
            print(f"Directory {modulename} already exists. Remove it or use --force to overwrite.",
                  file=sys.stderr)
            print("Exiting.", file=sys.stderr)
            sys.exit(4)

    # Install CMakeLists.txt and README in the top module directory
    for f in ("CMakeLists.txt", "README"):
        install_file(os.path.join(refbase, f), os.path.join(modulename, f),
                     force)
    
    # Create the source and build directories
    for d in ("source", "build"):
        os.mkdir(os.path.join(modulename, d), mode=0755)

    # Copy the source files from the template directory to source,
    # changing their names from oof2template.* to modulename.*
    suffixes = [".C", ".h", ".spy", ".swg"]
    for suffix in suffixes:
        install_file(os.path.join(refdir, "oof2template"+suffix),
                     os.path.join(modulename, "source", modulename+suffix),
                     force)
    # Create CMakeLists.txt in the subdirectory.
    install_file(os.path.join(basedir, "CMakeLists_subdir.txt"),
                 os.path.join(modulename, "source", "CMakeLists.txt"),
                 force)
        
    
    # file_list = [os.path.join(refdir,f) for f in os.listdir(refdir)]
    # # print file_list
    # for source in file_list:
    #     targetpath = source.split(os.sep)
    #     # print "targetpath0=", targetpath
    #     targetpath[0] = dirname
    #     # print "targetpath1=", targetpath
    #     for level, pathcomp in enumerate(targetpath[1:]):
    #         targetpath[level+1] = pathcomp.replace(templatedir, modulename)
    #     # print "targetpath2=", targetpath
    #     sedcmd = sedstart + [source]
    #     # print "targetpath=", targetpath
    #     target = os.path.join(*targetpath)

    #     install_file(source, target, sedcmd)
        
        # try:
        #     fout = file(target, "w")
        # except:
        #     print("Unable to open target file %s" % target, file=sys.stderr)
        #     print("Exiting.", file=sys.stderr)
        #     sys.exit(4)
        # print("Copying", source, "to", target)
        # p1 = subprocess.Popen(sedcmd, stdout=subprocess.PIPE)
        # for ell in p1.communicate():
        #     if ell is not None:
        #         fout.write(ell)
        # fout.close()
        # # else:
        # #     print "Not copying", source
